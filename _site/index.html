<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>Blog &middot; Jinyong Jeong</title><!--[if gt IE 8]><!----><style> article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html,body{margin:0;padding:0}html{line-height:1.65}body{color:#515151;background-color:#fff}a{text-decoration:none}img{display:block;max-width:100%;margin:0 0 1rem}img.lead{max-width:calc(100% + 2rem);width:calc(100% + 2rem);margin-left:calc(-1rem);margin-right:calc(-1rem)}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:600;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:2rem}h2{margin-top:1rem;font-size:1.5rem}p{margin-top:0;margin-bottom:1rem}p.lead{font-size:1.25rem;font-weight:300}ul,ol,dl{margin-top:0;margin-bottom:1rem}hr{position:relative;margin:1.5rem 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}.container{max-width:38rem;padding-left:1rem;padding-right:1rem;margin-left:auto;margin-right:auto}.page-title,.post-title{color:#303030}.page-title,.post-title{margin-top:0}.post-date{display:block;margin-top:-.25rem;margin-bottom:1rem;color:#9a9a9a;font-weight:bold}.related{padding-top:2rem;padding-bottom:2rem}.related-posts{padding-left:0;list-style:none}.related-posts>li{margin-top:1rem}.related-posts>li>*{font-weight:normal}.message{margin-bottom:1rem;padding:1rem;color:#717171;background-color:#f9f9f9;margin-left:-1rem;margin-right:-1rem}body{padding-left:0.5rem}@media (min-width: 48em){html{font-size:16px}body{padding-left:0}}@media (min-width: 58em){html{font-size:18px}}.sr-only{display:none}.backdrop{display:none}.sidebar{position:relative;z-index:4;padding:2rem 1rem;color:rgba(255,255,255,0.75);background-color:#202020;text-align:left;background-size:cover;background-position:center center;min-height:640px;min-height:100vh;margin-left:-0.5rem}.sidebar a{color:#fff}.sidebar ul{list-style:none;padding-left:0}.sidebar-sticky{position:absolute;right:1rem;bottom:1rem;left:1rem}.sidebar-about>h1{color:#fff;font-size:2rem}.sidebar-nav-item{font-weight:bold;display:block;line-height:1.75;padding:.25rem .1rem;border-top:1px solid rgba(255,255,255,0.23)}.sidebar-social>ul{min-height:3.5rem}.sidebar::before{content:"";position:absolute;top:0;left:0;bottom:0;right:0;background:rgba(32,32,32,0.33);background:-moz-linear-gradient(bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%);background:-webkit-linear-gradient(bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%);background:linear-gradient(to bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%)}@media (min-width: 48em){.sidebar{position:fixed;top:0;left:0;bottom:0;width:18rem;margin-left:0}}.menu{display:block;padding:1.25rem 1.5rem;color:#9a9a9a;border-bottom:none;position:fixed;top:0;left:0;z-index:2}@media (min-width: 48em){.menu{position:absolute;left:-9999px}}@media (min-width: 48em){.menu:focus{left:19.5rem}}@media (min-width: 64em){.menu:focus{left:21.5rem}}.content{padding-top:4rem;padding-bottom:4rem}@media (min-width: 48em){.content{max-width:38rem;margin-left:20rem;margin-right:2rem;border-left:none}}@media (min-width: 64em){.content{margin-left:22rem;margin-right:4rem}}.me{float:right;width:6.5rem;margin-top:-4.8rem;margin-left:1rem;border-radius:100%;position:relative}@media (min-width: 38em){.me{width:7rem;margin-top:-5.05rem}}@media (min-width: 48em){.me{width:6.5rem;margin-top:-4.8rem}}@media (min-width: 58em){.me{width:7rem;margin-top:-5.05rem}}</style><noscript><link rel="stylesheet" href="http://JinyongJeong.github.io/public/css/non-essentials.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700|PT+Serif:400,400italic,700,700italic"><link rel="stylesheet" href="http://JinyongJeong.github.io/public/css/icons.css"> </noscript><link rel="preload" href="http://JinyongJeong.github.io/public/css/non-essentials.css" as="style" onload="this.rel='stylesheet'"><style> html { font-family: "PT Serif", Georgia, serif; } :focus { outline-color: #A85641; } .font-accent { font-family: "Roboto Slab", "PT Serif", Georgia, serif; } .content a, .related-posts li a:hover { color: #A85641; } ::selection { color: #fff; background: #A85641; } ::-moz-selection { color: #fff; background: #A85641; } .sidebar { background-image: url('/public/img/6.jpg'); }</style><!--<![endif]--><link rel="canonical" href="http://localhost:4000http://JinyongJeong.github.io/" /><link rel="alternate" type="application/atom+xml" title="Jinyong Jeong Atom Feed" href="http://JinyongJeong.github.io/atom.xml"> <script>!function(n,e){function t(n,e){n.onload=function(){this.onerror=this.onload=null,e(null,n)},n.onerror=function(){this.onerror=this.onload=null,e(new Error("Failed to load "+this.src),n)}}function o(n,e){n.onreadystatechange=function(){"complete"!=this.readyState&&"loaded"!=this.readyState||(this.onreadystatechange=null,e(null,n))}}n.isReady=!1,n.loadJSDeferred=function(a,r){function d(){n.isReady=!0;var d=e.createElement("script");d.src=a,r&&(("onload"in d?t:o)(d,r),d.onload||t(d,r));var i=e.getElementsByTagName("script")[0];i.parentNode.insertBefore(d,i)}n.isReady?d():n.addEventListener?n.addEventListener("load",d,!1):n.attachEvent?n.attachEvent("onload",d):n.onload=d}}(window,document); </script> <!--[if lt IE 9]> <script src="https://unpkg.com/html5shiv/dist/html5shiv.min.js"></script> <![endif]--><body> <span class="sr-only">Jump to:</span> <a id="_menu" class="menu" href="#_asidebar"> <span>☰</span> <span class="sr-only">Menu</span> </a><main class="content container" role="main"><article id="post-2017/01/13/blog_make_searched" class="post" role="article"><h1 class="post-title"> <a href="http://JinyongJeong.github.io/2017/01/13/blog_make_searched/"> github blog를 google에서 검색되도록 설정하기 </a></h1><div class="post-date"> <time datetime="2017-01-13T00:00:00+09:00">01/13/17</time> <span>on <a href="http://JinyongJeong.github.io/tag/jekyll/">Jekyll</a></span></div><p class="message">github io와 같은 개인 블로그를 google과 naver, 그리고 daum과 같은 포탈사이트에서 검색 가능하도록 만드는 방법<hr/><p>이 글은 다음 <a href="http://dveamer.github.io/homepage/SubmitSitemap.html">blog</a>의 글을 참고하였습니다.<p>네이버 블로그와 같은 포탈의 블로그 서비스를 사용할 경우 자동으로 검색이 가능하지만, github와 같은 플렛폼을 사용할 경우에는 직접 각 포탈에 검색이 가능하도록 등록을 해 주어야 한다. 이 글에서는 블로그의 글이 google, daum, naver에서 검색 가능하도록 등록하는 방법에 대해서 설명한다.<h2 id="1-sitemap-생성">1. sitemap 생성</h2><p>sitemap을 google에 등록해 두면 주기적으로 크롤링을 통해 url을 연결시킨다. 우선 sitemap을 생성하는 방법에 대해서 설명한다. ruby를 통해 jekyll 홈페이지를 만든 경우에는 <code class="highlighter-rouge">sudo gem install jekyll-sitemap</code> 의 명령어를 이용해 플러그인을 사용할 수 있다. 하지만 여기서는 플러그인을 사용하지 않는 방법을 설명한다.<p>블로그의 <code class="highlighter-rouge">/root</code> 경로에 <code class="highlighter-rouge">/sitemap.xml</code> 파일을 만들고 아래의 내용을 복사해 넣는다. 반드시 root 디렉토리에 넣어야 한다.<div class="highlighter-rouge"><pre class="highlight"><code>
---
layout: null
---
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;urlset xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd" xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"&gt;
  {% for post in site.posts %}
    &lt;url&gt;
      &lt;loc&gt;{{ site.url }}{{ post.url }}&lt;/loc&gt;
      {% if post.lastmod == null %}
        &lt;lastmod&gt;{{ post.date | date_to_xmlschema }}&lt;/lastmod&gt;
      {% else %}
        &lt;lastmod&gt;{{ post.lastmod | date_to_xmlschema }}&lt;/lastmod&gt;
      {% endif %}

      {% if post.sitemap.changefreq == null %}
        &lt;changefreq&gt;weekly&lt;/changefreq&gt;
      {% else %}
        &lt;changefreq&gt;{{ post.sitemap.changefreq }}&lt;/changefreq&gt;
      {% endif %}

      {% if post.sitemap.priority == null %}
          &lt;priority&gt;0.5&lt;/priority&gt;
      {% else %}
        &lt;priority&gt;{{ post.sitemap.priority }}&lt;/priority&gt;
      {% endif %}

    &lt;/url&gt;
  {% endfor %}
&lt;/urlset&gt;

</code></pre></div><p>git과 commit으로 블로그를 업데이트 후 <code class="highlighter-rouge">blog주소/sitemap.xml</code>로 접속했을 때 아래와 같은 화면이 나와야 정상적으로 sitemap이 등록된 것이다.<p><img align="middle" src="/images/post/jekyll/google_search/sitemap.png" width="700" /><p>sitemap에는 각 해당 글의 lastmod, sitemap.changefreq, sitemap.prioritye 등의 정보가 설정되는데, 이것은 각 글의 맨 위에 다음과 같이 sitemap의 옵션을 추가해 줌으로써 추가적으로 설정 가능하다. 설정이 없을 때의 default 설정은 <code class="highlighter-rouge">sitemap.xml</code>에 정의되어 있다.<div class="highlighter-rouge"><pre class="highlight"><code>
---
layout: post
title:  "제목"
date:   2016-03-14 12:00:00 
lastmod : 2016-03-15 12:00:00
sitemap :
  changefreq : daily
  priority : 1.0
---

</code></pre></div><p>changefreq를 너무 짧게 하면 빈번한 접속으로 안좋은 영향을 미칠 수도 있다고 하니 적당히 하루 혹은 일주일로 하면 좋을 것 같다. 추가적으로 <code class="highlighter-rouge">blog주소/sitemap.xml</code>을 실행했을 때 위와 같이 나오지 않는 경우는 아마 주소링크에 &amp;와 같은 특수기호가 있는 경우가 있을 수 있다. 예를들어 파일의 이름이 URL의 링크 주소가 되는데, 만약 파일이름이 한글일 경우 url의 주소에 %의 기호가 들어가 있다. 이럴경우 xml이 정상적으로 해석하지 못한다. 따라서 최대한 URL의 링크가 되는 파일이름은 영문으로 만들고, 특수기호는 최대한 사용하지 않는 것이 좋다.<h2 id="2-rss-feed-생성">2. RSS feed 생성</h2><p>Rss feed는 naver와 daum에 등록하기 위함이다. <code class="highlighter-rouge">sitemap.xml</code>과 마찬가지로 root 디렉토리에 <code class="highlighter-rouge">/feed.xml</code>파일을 생성하고 아래의 코드를 복사한다.<div class="highlighter-rouge"><pre class="highlight"><code>
---
layout: null
---
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;channel&gt;
    &lt;title&gt;{{ site.title | xml_escape }}&lt;/title&gt;
    &lt;description&gt;{{ site.description | xml_escape }}&lt;/description&gt;
    &lt;link&gt;{{ site.url }}{{ site.baseurl }}/&lt;/link&gt;
    &lt;atom:link href="{{ "/feed.xml" | prepend: site.baseurl | prepend: site.url }}" rel="self" type="application/rss+xml"/&gt;
    &lt;pubDate&gt;{{ site.time | date_to_rfc822 }}&lt;/pubDate&gt;
    &lt;lastBuildDate&gt;{{ site.time | date_to_rfc822 }}&lt;/lastBuildDate&gt;
    &lt;generator&gt;Jekyll v{{ jekyll.version }}&lt;/generator&gt;
    {% for post in site.posts limit:30 %}
      &lt;item&gt;
        &lt;title&gt;{{ post.title | xml_escape }}&lt;/title&gt;
        &lt;description&gt;{{ post.content | xml_escape }}&lt;/description&gt;
        &lt;pubDate&gt;{{ post.date | date_to_rfc822 }}&lt;/pubDate&gt;
        &lt;link&gt;{{ post.url | prepend: site.baseurl | prepend: site.url }}&lt;/link&gt;
        &lt;guid isPermaLink="true"&gt;{{ post.url | prepend: site.baseurl | prepend: site.url }}&lt;/guid&gt;
        {% for tag in post.tags %}
        &lt;category&gt;{{ tag | xml_escape }}&lt;/category&gt;
        {% endfor %}
        {% for cat in post.categories %}
        &lt;category&gt;{{ cat | xml_escape }}&lt;/category&gt;
        {% endfor %}
      &lt;/item&gt;
    {% endfor %}
  &lt;/channel&gt;
&lt;/rss&gt;

</code></pre></div><h2 id="3-robotstxt-생성">3. robots.txt 생성</h2><p><code class="highlighter-rouge">robots.txt</code>파일에 <code class="highlighter-rouge">sitemap.xml</code>파일의 위치를 등록해 두면 검색엔진의 크롤러들이 홈페이지를 크롤링하는데 도움을 주게 된다고 한다. root 디렉토리에 <code class="highlighter-rouge">/robots.txt</code> 파일을 만들고 아래와 같이 입력한다.<div class="highlighter-rouge"><pre class="highlight"><code>User-agent: *
Allow: /

Sitemap: http://jinyongjeong.github.io/sitemap.xml
</code></pre></div><p><code class="highlighter-rouge">User-agent</code>는 허용할 검색엔진 명을 넣게 된다. 따로 설정하지 않으면(*) 모든 검색엔진을 허용하게 된다. 자세한 내용은 <a href="http://dveamer.github.io/homepage/SubmitSitemap.html">http://dveamer.github.io/homepage/SubmitSitemap.html</a>를 참고한다.<h2 id="4-사이트-등록">4. 사이트 등록</h2><h3 id="google-google-search-console등록">google (google search console등록)</h3><p><a href="https://www.google.com/webmasters/#?modal_active=none">Google Search Console</a>를 접속한다.<p>이 사이트에서 본인의 블로그를 등록해야 google에서 검색이 가능하다. <code class="highlighter-rouge">속성추가</code> 버튼을 눌러 본인의 blog 주소를 입력하여 사이트를 등록한다. <code class="highlighter-rouge">크롤링 &gt; sitemaps</code> 메뉴를 열어 <code class="highlighter-rouge">sitemap 추가</code> 버튼을 눌러 만들어 두었던 <code class="highlighter-rouge">sitemap.xml</code>파일을 제출한다. 제출이 완료되면 <code class="highlighter-rouge">sitemap.xml</code>파일이 등록된 것을 확인할 수 있으며 색인이 접수 중임을 알 수 있다.<h3 id="naver">naver</h3><p><a href="http://webmastertool.naver.com/">네이버 웹마스터 도구</a>에 접속한다.<p>로그인하여 구글과 비슷하게 블로그 주소를 등록하는 과정을 거친다. 그 후 “사이트 소유 확인”이라는 과정을 거치게 되는데 HTML 파일을 다운받아 블로그의 root에 업로드 하여 확인하는 과정을 거치게 된다. 이 과정을 거치면 google의 analystics와 유사한 기능을 사용할 수 있는 것 같다. 그 다음에 RSS를 등록하는 과정이 필요하다. 왼쪽 메뉴에서 <code class="highlighter-rouge">요청 &gt; RSS제출</code> 을 클릭해서 URL을 포함한 주소인 <code class="highlighter-rouge">블로그URL/feed.xml</code>을 입력한다. 추가적으로 <code class="highlighter-rouge">요청 &gt; 사이트맵제출</code>로 들어가서 google과 마찬가지로 <code class="highlighter-rouge">블로그URL/sitemap.xml</code>을 입력해서 sitemap을 등록시켜 준다.<h3 id="daum">daum</h3><p><a href="https://register.search.daum.net/index.daum">DAUM 검색등록</a>에 접속 후 로그인한다.<p><code class="highlighter-rouge">등록</code> 탭에서 <code class="highlighter-rouge">블로그 RSS등록</code>을 선택하고 <code class="highlighter-rouge">블로그URL</code>에 본인의 URL을 입력하고 확인버튼을 누른다. 이전 블로그에서 보면 <code class="highlighter-rouge">feed.xml</code>파일을 올리는 RSS 부분이 있었는데 지금 확인해보니 URL을 입력하는 창만 뜬다. 우선 URL만 등록해보도록 한다.<p>위의 과정을 거치고 최종으로 반영되기 까지 어느정도의 시간이 걸린다. 일주일정도 시간이 흐른뒤에 확인해보도록 하자.</article><br/><article id="post-2017/01/13/SLAM_bayes_filter" class="post" role="article"><h1 class="post-title"> <a href="http://JinyongJeong.github.io/2017/01/13/SLAM_bayes_filter/"> [SLAM] Bayes filter(베이즈 필터)/ motion and observation model </a></h1><div class="post-date"> <time datetime="2017-01-13T00:00:00+09:00">01/13/17</time> <span>on <a href="http://JinyongJeong.github.io/tag/SLAM/">SLAM</a></span></div><p class="message">SLAM framework에서 Bayes filter와 motion, observation model에 대한 설명.<hr/><p>&lt;본 글은 University Freiburg의 <a href="http://ais.informatik.uni-freiburg.de/teaching/ws13/mapping/">Robot Mapping</a> 강의를 바탕으로 이해하기 쉽도록 정리하려는 목적으로 작성되었습니다. 개인적인 의견을 포함하여 작성되기 때문에 틀린 부분을 지적해주시면 확인 후 수정토록 하겠습니다.&gt;<h2 id="slamsimultaneous-localization-and-mapping">SLAM(Simultaneous Localization and Mapping)</h2><p>SLAM은 simultaneous localization and mapping의 줄임말로 위치추정(localization)과 지도생성(mapping)을 동시에 하는 연구분야를 의미한다. 이는 닭이 먼저냐 달걀이 먼저냐의 문제와 비슷하다. 자기의 위치를 추정하기 위해서는 주변환경에 대한 정보가 필요하다. 반면에 로봇이 얻을 수 있는 데이터를 이용해서 지도를 만들기 위해서는 로봇이 자신의 위치가 어디에 있는지를 정확히 알아야 한다. 따라서 위치를 알 수 없으면 지도를 만들 수 없고, 반대로 지도가 없으면 위치를 알 수 없다. 이러한 문제를 풀기 위해서 지도의 생성과 위치 추정을 동시에 수행하는 것이 SLAM이다.<h3 id="state-estimation">State estimation</h3><p>State estimation은 로봇에 주어지는 입력과, 로봇의 센서로부터 얻어지는 데이터로부터 현재의 로봇의 위치인 state와 주변환경에 대한 지도를 추정 방법이다.<pre class="MathJax_Preview"><code>p(\mathbf{x}\mid \mathbf{z}, \mathbf{u})</code></pre><script type="math/tex; mode=display">p(\mathbf{x}\mid \mathbf{z}, \mathbf{u})</script><p>위의 식은 기본적인 state estimation을 의미한다. <code class="MathJax_Preview">\mathbf{x}</code><script type="math/tex">\mathbf{x}</script> 는 로봇의 위치 및 지도(주변의 land mark들의 위치)를 의미하는 vector이며, <code class="MathJax_Preview">\mathbf{z}</code><script type="math/tex">\mathbf{z}</script> 는 로봇의 센서로부터 얻어지는 데이터로 observation이라고 부르며, <code class="MathJax_Preview">\mathbf{u}</code><script type="math/tex">\mathbf{u}</script> 는 센서의 움직임을 제어하는 입력으로 control input이라고 부른다. state estimation은 이러한 control input과 observation의 데이터를 통해 현재의 위치와 지도를 추정한다.<h3 id="bayes-theorem">bayes theorem</h3><p>베이즈 정리는 확률론과 통계학에서 두 확률변수의 사전확률(prior)과 사후확률(posterior) 사이의 관계를 나타내는 정리이다.<pre class="MathJax_Preview"><code>P(A \mid B) = \frac{P(B \mid A)P(A)}{P(B)}</code></pre><script type="math/tex; mode=display">P(A \mid B) = \frac{P(B \mid A)P(A)}{P(B)}</script><p><code class="MathJax_Preview">P(A)</code><script type="math/tex">P(A)</script> 는 A의 prior로, 사건 B에 대한 어떠한 정보를 알지 못하는 것을 의미한다. <code class="MathJax_Preview">P(A \mid B)</code><script type="math/tex">P(A \mid B)</script> 는 B의 값이 주어진 경우 A의 posterior이다. <code class="MathJax_Preview">P(B \mid A)</code><script type="math/tex">P(B \mid A)</script> 는 A가 주어졌을 때 B의 조건부 확률이다.<p>bayes 정리의 자세한 내용은 <a href="https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%EC%A0%95%EB%A6%AC">wiki</a>를 참고한다.<h3 id="recursive-bayes-filter">Recursive bayes filter</h3><p>위에서 설명한 state estimation은 bayes filter의 과정으로 설명할 수 있으며, 각 step의 state를 반복적으로 계산함으로써 계산할 수 있기 때문에 recursive bayes filter로 부른다. 전체적인 recursive bayes filter의 식은 다음과 같다.<pre class="MathJax_Preview"><code>\begin{aligned}
bel(x_t) &amp;= p(x_t \mid z_{1:t},u_{1:t}) \\
       &amp;= \eta p(z_t \mid x_t, z_{1:t-1}, u_{1:t})p(x_t \mid z_{1:t-1},u_{1:t}) \\
       &amp;= \eta p(z_t \mid x_t)p(x_t \mid z_{1:t-1},u_{1:t}) \\
       &amp;= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, z_{1:t-1}, u_{1:t})p(x_{t-1} \mid z_{1:t-1}, u_{1:t}) dx_{t-1}\\
       &amp;= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t})p(x_{t-1} \mid z_{1:t-1}, u_{1:t}) dx_{t-1}\\
       &amp;= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t})p(x_{t-1} \mid z_{1:t-1}, u_{1:t-1}) dx_{t-1}\\
       &amp;= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}\\
\end{aligned}</code></pre><script type="math/tex; mode=display">% <![CDATA[ \begin{aligned} bel(x_t) &= p(x_t \mid z_{1:t},u_{1:t}) \\ &= \eta p(z_t \mid x_t, z_{1:t-1}, u_{1:t})p(x_t \mid z_{1:t-1},u_{1:t}) \\ &= \eta p(z_t \mid x_t)p(x_t \mid z_{1:t-1},u_{1:t}) \\ &= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, z_{1:t-1}, u_{1:t})p(x_{t-1} \mid z_{1:t-1}, u_{1:t}) dx_{t-1}\\ &= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t})p(x_{t-1} \mid z_{1:t-1}, u_{1:t}) dx_{t-1}\\ &= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t})p(x_{t-1} \mid z_{1:t-1}, u_{1:t-1}) dx_{t-1}\\ &= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}\\ \end{aligned} %]]></script><p>위의 식은 recursive bayes filter를 유도하는 과정을 모두 표현하고 있기 때문에 다소 복잡해 보인다. 우선 전체적인 식을 이해하기 위해서 맨 처음과 맨 마지막 식만을 보면 다음과 같다.<pre class="MathJax_Preview"><code>\begin{aligned}
bel(x_t)  &amp;= p(x_t \mid z_{1:t},u_{1:t}) \\
          &amp;= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}\\
\end{aligned}</code></pre><script type="math/tex; mode=display">% <![CDATA[ \begin{aligned} bel(x_t) &= p(x_t \mid z_{1:t},u_{1:t}) \\ &= \eta p(z_t \mid x_t)\int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}\\ \end{aligned} %]]></script><p><code class="MathJax_Preview">bel(x_t)</code><script type="math/tex">bel(x_t)</script> 는 처음부터 현재까지의 observation( <code class="MathJax_Preview">z</code><script type="math/tex">z</script> )와 control input( <code class="MathJax_Preview">u</code><script type="math/tex">u</script> )을 알고 있을 때 현재 state( <code class="MathJax_Preview">x_t</code><script type="math/tex">x_t</script> )의 확률을 의미한다. 위의 식에서 <code class="MathJax_Preview">bel(x_t)</code><script type="math/tex">bel(x_t)</script> 의 식은 <code class="MathJax_Preview">bel(x_{t-1})</code><script type="math/tex">bel(x_{t-1})</script> 의 integral로 표현되어 있기 때문에 만약 <code class="MathJax_Preview">p(z_t \mid x_t)</code><script type="math/tex">p(z_t \mid x_t)</script> 와 <code class="MathJax_Preview">p(x_t \mid x_{t-1}, u_t)</code><script type="math/tex">p(x_t \mid x_{t-1}, u_t)</script> 에 대한 정보를 알고 있다면 반복적인 계산을 통해 현재 state의 확률을 계산할 수 있음을 알 수 있다. 여기서 <code class="MathJax_Preview">p(z_t \mid x_t)</code><script type="math/tex">p(z_t \mid x_t)</script> 는 현재의 state에서 센서 데이터의 확률인 observation model이며, $$p(x_t \mid x_{t-1}, u_t)$ 은 현재의 control input에 대해 이전 state에서 현재 state로의 update를 나타내는 motion model를 의미한다. 위의 식을 Recursive bayes filter라고 한다. Recursive bayes filter는 SLAM 문제를 푸는데 가장 기본적인 식이 되며, Kalman filter의 기본적인 식이다. 다음은 recursive bayes filter의 유도과정을 간단하게 살펴본다. 유도에 관심이 없고 전체적인 흐름만 보고자 한다면 다음 설명은 넘어가도 좋다.<h4 id="recursive-bayes-filter의-유도과정">Recursive bayes filter의 유도과정</h4></article><br/><article id="post-2017/01/09/subline_text" class="post" role="article"><h1 class="post-title"> <a href="http://JinyongJeong.github.io/2017/01/09/subline_text/"> Ubuntu Sublime text 설치하기 </a></h1><div class="post-date"> <time datetime="2017-01-09T00:00:00+09:00">01/09/17</time> <span>on <a href="http://JinyongJeong.github.io/tag/ubuntu/">Ubuntu</a><span>, </span><a href="http://JinyongJeong.github.io/tag/IRAP/">IRAP</a></span></div><p class="message">Sublime text 설치 후 셋팅하는 방법을 설명한다.<hr/><h1 id="sublimetext3">SublimeText3</h1><h3 id="1-sublime-text-설치하기">1. sublime text 설치하기</h3><h5 id="sublimetext-에서-다운로드-후-설치"><a href="http://www.sublimetext.com/">sublimetext</a> 에서 다운로드 후 설치</h5><h5 id="ppa-이용한-설치-방법">ppa 이용한 설치 방법</h5><div class="highlighter-rouge"><pre class="highlight"><code>sudo add-apt-repository ppa:webupd8team/sublime-text-3
sudo apt-get update
sudo apt-get install sublime-text-installer
</code></pre></div><h3 id="2-project-를-위한-패키지-구성">2. Project 를 위한 패키지 구성</h3><h5 id="package-control-설치">Package Control 설치</h5><p>메뉴 View -&gt; Show Consol (Ctrl+`) 실행후 console 창을 열어서 아래의 명령어 입력후 에디터 재시작 Sublime text 버전에 따라 다르게 입력<p>Sublime Text 2<div class="highlighter-rouge"><pre class="highlight"><code>import urllib2,os; pf='Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/' +pf.replace( ' ','%20' )).read()); print( 'Please restart Sublime Text to finish installation')
</code></pre></div><p>Sublime Text 3<div class="highlighter-rouge"><pre class="highlight"><code>import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())
</code></pre></div><h4 id="ycmdcompletion-패키지">YcmdCompletion 패키지</h4><h5 id="1-ycmdcompletion-설치">1. YcmdCompletion 설치</h5><ul><li><p>Sublime Text에서 Command Palette (Ctrl+Shift+P)창을 열어서 ‘Package Control : Install Pacakge’ 실행 후 ‘YcmdCompletion’ 찾아서 설치<li><p>YcmdCompletion은 기본적으로 Ycmd server를 이용해서 code-completion을 수행. ycmd server가 설치 되어있지 않으면 다음 단계로 ycmd 를 설치해야함.</ul><h5 id="2-ycmd-server-설치">2. Ycmd server 설치</h5><ul><li>Ycmd의 github 원격 저장소를 복제후 submodule 업데이트</ul><div class="highlighter-rouge"><pre class="highlight"><code>git clone https://github.com/Valloric/ycmd.git
cd ycmd
git submodule update --init --recursive
</code></pre></div><ul><li>Ycmd 빌드</ul><div class="highlighter-rouge"><pre class="highlight"><code>./build.py --all
</code></pre></div><h5 id="3-ycmdcompletion-설정">3. YcmdCompletion 설정</h5><h6 id="hmac-key-생성">HMAC key 생성</h6><p>Command Pallete (Ctrl+Shift+p) -&gt; Ycmd: Create HMAC keys<h6 id="sublime-text의-ycmd-completion-설정">Sublime Text의 Ycmd Completion 설정</h6><p>Preferences -&gt; Package Settings -&gt; YcmdCompletion -&gt; Settings - Default 클릭 후 YcmdCompletion.sublime-settings 파일의 주석 처리된 부분을 풀어서 다음과 같이 입력<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"ycmd_server"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://127.0.0.1"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"ycmd_port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8080</span><span class="p">,</span><span class="w">
    </span><span class="nt">"HMAC"</span><span class="p">:</span><span class="w"> </span><span class="s2">"위에서 생성한 HMAC key"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"use_auto_start_localserver"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nt">"ycmd_path"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/home/USERNAME/ycmd/ycmd"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"languages"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"cpp"</span><span class="p">,</span><span class="w"> </span><span class="s2">"python"</span><span class="p">],</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre></div><h6 id="sublime-text의-syntax-specific-추가">Sublime Text의 Syntax Specific 추가</h6><p>Preferences -&gt; Settings - More -&gt; Syntax Specific - User 클릭 후 C++.sublime-settings에 다음 내용 추가(c++ 프로젝트 혹은 파일을 열었을 때 C++.sublime-settings을 열 수 있다.<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"auto_complete_selector"</span><span class="p">:</span><span class="w"> </span><span class="s2">"source - (comment, string.quoted)"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"auto_complete_triggers"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> 
        </span><span class="p">{</span><span class="nt">"selector"</span><span class="p">:</span><span class="w"> </span><span class="s2">"source.c++"</span><span class="p">,</span><span class="w"> </span><span class="nt">"characters"</span><span class="p">:</span><span class="w"> </span><span class="s2">"."</span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="nt">"selector"</span><span class="p">:</span><span class="w"> </span><span class="s2">"source.c++"</span><span class="p">,</span><span class="w"> </span><span class="nt">"characters"</span><span class="p">:</span><span class="w"> </span><span class="s2">"::"</span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="nt">"selector"</span><span class="p">:</span><span class="w"> </span><span class="s2">"source.c++"</span><span class="p">,</span><span class="w"> </span><span class="nt">"characters"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-&gt;"</span><span class="p">}</span><span class="w"> 
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div><h6 id="sublime-project-생성하기">Sublime project 생성하기</h6><ul><li>CMake를 이용하는 방법</ul><div class="highlighter-rouge"><pre class="highlight"><code>cd build
cmake . -G "Sublime Text 2 - Unix Makefiles"
</code></pre></div><ul><li>CMakeLists.txt 를 이용하는 방법</ul><p>project의 root의 CMakeLists.txt에 다음 항목 추가<div class="highlighter-rouge"><pre class="highlight"><code>set(CMAKE_EXPORT_COMPILE_COMMANDS "ON")
set(CMAKE_GENERATOR "Unix Makefiles" CACHE INTERNAL "" FORCE)
set(CMAKE_EXTRA_GENERATOR "Sublime Text 2" CACHE INTERNAL "" FORCE)
</code></pre></div><h6 id="ycmd-default_settingsjson-파일-설정">Ycmd default_settings.json 파일 설정</h6><p>위에서 복제한 ycmd server directory에서 default_settings.json 파일 내용 중 아래 부분 변경<div class="highlighter-rouge"><pre class="highlight"><code>  "global_ycm_extra_conf": "/home/ycmd/ycmd/.ycm_extra_conf.py",
  "confirm_extra_conf": 0,
  "hmac_secret": "위의 HMAC key 입력",
</code></pre></div><h6 id="ycm_extra_confpy-파일-설정하기"><a href="https://github.com/Valloric/ycmd/blob/master/cpp/ycm/.ycm_extra_conf.py">.ycm_extra_conf.py</a> 파일 설정하기</h6><ul><li>gobal ycm_conf 설정 : ycmd server의 default_settings.json 파일의 “global_ycm_extra_conf” 설정 경로에 위 링크 파일 복사<li>local ycm_conf 설정 : 해당 프로젝트의 root에 .ycmd_extra_conf.py복사 후 compilation_database_folder 값을 아래와 같이 변경</ul><div class="highlighter-rouge"><pre class="highlight"><code>compilation_database_folder = os.path.expanduser("~/projects/naver/build")
</code></pre></div><h6 id="ycm-generator-이용해서-ycm_extra_confpy-만들기">YCM-Generator 이용해서 .ycm_extra_conf.py 만들기</h6><p>YCM-Generator를 github repository로부터 복제<div class="highlighter-rouge"><pre class="highlight"><code>git clone https://github.com/rdnetto/YCM-Generator.git
</code></pre></div><p>프로젝트 디렉토리에 .ycm_extra_conf.py 만들기<div class="highlighter-rouge"><pre class="highlight"><code>cd YCM-Generator
./config_gen.py 프로젝트디렉토리
</code></pre></div><p>위의 프로그램을 수행하면 프로젝트디렉토리의 root에 .ycm_extra_conf.py파일이 생성됨</article><br/><article id="post-2017/01/09/pcl_install_with_qt5" class="post" role="article"><h1 class="post-title"> <a href="http://JinyongJeong.github.io/2017/01/09/pcl_install_with_qt5/"> 원하는 QT 버전에 맞게 PCL 설치하기 </a></h1><div class="post-date"> <time datetime="2017-01-09T00:00:00+09:00">01/09/17</time> <span>on <a href="http://JinyongJeong.github.io/tag/ubuntu/">Ubuntu</a></span></div><p class="message">PCL을 설치할 때 원하는 QT버전으로 지정하여 설치하는 방법에 대해서 설명한다.<hr/><p>원하는 버전의 QT5와 VTK, PCL을 설치하는 방법에 대해 설명한다.<p>일반적인 방법으로 PCL을 설치할 경우 PCL의 기본 QT의 경로가 /usr/lib/x86_64-linux-gnu/ 로 잡히게 된다.<p>그러나 일반적으로 QT5를 sudo로 설치할 경우 /opt 에 설치되기 때문에 경로를 설정해줘야 한다.<p>VTK와 PCL를 제외한 나머지 dependency는 설치 되어 있다고 하자.(openni 등)<p>QT5 또한 원하는 버전을 /opt/에 설치한 경우이다.<h1 id="1-vtk-설치">1. VTK 설치</h1><p>git clone으로 VTK를 다운받아 준다<div class="highlighter-rouge"><pre class="highlight"><code>git clone https://github.com/Kitware/VTK.git
</code></pre></div><p>그런 다음 build 폴더를 만들어서 build폴더로 이동한 후 다음 옵션으로 cmake해준다. 옵션으로 Qt5의 경로를 지정해준다.<div class="highlighter-rouge"><pre class="highlight"><code>cd build

cmake -DVTK_QT_VERSION:STRING=5 -DQT_QMAKE_EXECUTABLE:PATH=/opt/Qt5.6.1/5.6/gcc_64/bin/qmake -DVTK_Group_Qt:BOOL=ON -DCMAKE_PREFIX_PATH:PATH=/opt/Qt5.6.1/5.6/gcc_64/lib/cmake -DBUILD_SHARED_LIBS:BOOL=ON ..
</code></pre></div><p>그다음 설치해준다.<div class="highlighter-rouge"><pre class="highlight"><code>make -j8
sudo make install
</code></pre></div><h1 id="2-pcl-설치">2. PCL 설치</h1><p>git 에서 다운받는다<div class="highlighter-rouge"><pre class="highlight"><code>git clone https://github.com/PointCloudLibrary/pcl.git
</code></pre></div><p>PCL의 qt5 경로를 설정해주기 위해서 cmake file에서 prefix 를 설정한다. /pcl/cmake/pcl_find_qt5.cmake 를 열고 최 상단에 아래의 setting을 추가<div class="highlighter-rouge"><pre class="highlight"><code>set(CMAKE_PREFIX_PATH /opt/Qt5.6.1/5.6/gcc_64/lib/cmake)
</code></pre></div><p>이제 build 폴더를 만들고 빌드 후 설치한다.<div class="highlighter-rouge"><pre class="highlight"><code>mkdir build
cd build
cmake ..
maek -j8
make install
</code></pre></div></article><br/><article id="post-2017/01/08/jekyll_blog_making_new" class="post" role="article"><h1 class="post-title"> <a href="http://JinyongJeong.github.io/2017/01/08/jekyll_blog_making_new/"> Jekyll을 이용하여 Github Blog 만들기 </a></h1><div class="post-date"> <time datetime="2017-01-08T00:00:00+09:00">01/08/17</time> <span>on <a href="http://JinyongJeong.github.io/tag/jekyll/">Jekyll</a></span></div><p class="message">Jekyll을 이용한 간편하게 Github에 blog를 만드는 방법 소개<hr/><h2 id="ruby와-jekyll-설치">Ruby와 Jekyll 설치</h2><p>Jekyll을 이용하여 github의 Blog를 만들어보도록 하자. 우선 Jekyll을 설치하기 위해서는 ruby를 설치해야 한다. 아래명령어를 이용하여 ruby를 설치한 후 Jekyll을 설치한다.<div class="highlighter-rouge"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install ruby-full
sudo gem install jekyll
</code></pre></div><p>Jekyll이 설치되었으면 설치가 잘 되었는지 확인하기 위해 버전을 확인한다.<div class="highlighter-rouge"><pre class="highlight"><code>jekyll -v
</code></pre></div><p>각 blog의 종류에 따라 다르지만 아래의 명령어를 통해 추가 패키지를 설치해주자.<div class="highlighter-rouge"><pre class="highlight"><code>sudo gem install jekyll-sitemap
sudo gem install jekyll-paginate
</code></pre></div><h2 id="github의-repository를-생성">github의 repository를 생성</h2><p><a href="http://www.github.com">Github</a>으로 접속 후 새로운 repository 생성. <yourname>.github.io 로 repository 생성 후 로컬에서 home folder로 이동하여 repository 복사.</yourname><div class="highlighter-rouge"><pre class="highlight"><code>git clone https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git
</code></pre></div><p>폴더를 복사 후 그 폴더로 이동한 후 git 을 초기화시킨다. 초기화 시킨 후 git의 폴더에 jekyll의 기본 테마 설치<div class="highlighter-rouge"><pre class="highlight"><code>git init
jekyll new . --force 
</code></pre></div><p>Jekyll로 생성된 모든 파일을 git에 add해 준 후 commit, push 를 해서 github에 올려준다.<div class="highlighter-rouge"><pre class="highlight"><code>git add *
git commit -m "first commit"
git push -u origin master
</code></pre></div><p>첫 commit 시에 config 파일에 user.email과 user.name을 등록하라고 나오면<div class="highlighter-rouge"><pre class="highlight"><code>git config user.email "이메일주소"
git config user.name "이름"
</code></pre></div><p>을 입력하여 이메일과 이름을 등록해 준다.이로써 github에 블로그가 생성되었다!<p>git을 clone 받은 후 처음에는 <code class="highlighter-rouge">git push -u origin master</code>를 모두 입력해야 하지만 한번 한 이후에는 <code class="highlighter-rouge">git push</code>만 입력해도 된다.<h2 id="blog-작성">Blog 작성</h2><p>블로그 작성 시 입력한 내용이 예상한대로 동작을 하는지 확인 하기 위해서 매번 github에 push하는 것은 매우 힘든 일이다. 작성을 하는 동시에 바로 확인을 하기 위해서 위에서 언급한 것과 같이 <code class="highlighter-rouge">jekyll serve</code>를 이용하여 서버를 동작 시킨 후 <code class="highlighter-rouge">localhost:4000</code>으로 접속하면 바로 수정된 내용을 확인할 수 있다. 이렇게 수정이 완료된 후 github로 push하면 편하게 포스팅을 수정할 수 있다.</article><br/><h2 class="sr-only">Pagination</h2><nav class="pagination" role="navigation"><ul><li class="pagination-item older" > <a rel="next" href="http://JinyongJeong.github.io/page-2">Older</a><li class="pagination-item newer" > <span>Newer</span></ul></nav></main><div id="_backdrop" class="backdrop"></div><header id="_sidebar" class="sidebar" role="banner"><div id="_asidebar" class="container sidebar-sticky"><div class="sidebar-about"><h1 class="font-accent"><a href="http://JinyongJeong.github.io/">Jinyong Jeong</a></h1><p>Various subjects such as ubuntu, computer vision algorithm will be posted in this blog. This blog is to remember what I studied.</div><nav class="sidebar-nav font-accent" role="navigation"><ul><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/post/">All post</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/SLAM/">SLAM</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/ubuntu/">Ubuntu</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/jekyll/">Jekyll</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/software/">Software</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/math/">Math</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/IRAP/">IRAP</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/about/">About</a></ul></nav><div class="sidebar-social"><ul><li> <a href="https://facebook.com/jinyong.jeong.399"> <span class="icon-facebook"></span> <span class="sr-only">facebook</span> </a><li> <a href="https://www.youtube.com/channel/UCPuPw9OXrBzYue3Sv4uvVxQ"> <span class="icon-youtube"></span> <span class="sr-only">youtube</span> </a><li> <a href="https://github.com/JinyongJeong"> <span class="icon-github"></span> <span class="sr-only">github</span> </a></ul></div></div></header><!--[if gt IE 8]><!----> <script>loadJSDeferred('http://JinyongJeong.github.io/public/js/hydejack.min.js')</script> <script> WebFontConfig = { google: { families: 'Roboto+Slab:700|PT+Serif:400,400italic,700,700italic'.split('|') }, custom: { families: ['icomoon'], urls: ['http://JinyongJeong.github.io/public/css/icons.css'] }, classes: false, events: false }; </script> <script>loadJSDeferred('https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js')</script> <script> window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-84025722-2', 'auto'); ga('send', 'pageview'); </script> <script>loadJSDeferred('https://www.google-analytics.com/analytics.js')</script> <!--<![endif]-->
